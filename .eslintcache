[{"/home/myron/Desktop/Projects/carbon-crush/src/index.js":"1","/home/myron/Desktop/Projects/carbon-crush/src/Homepage.js":"2","/home/myron/Desktop/Projects/carbon-crush/src/reportWebVitals.js":"3","/home/myron/Desktop/Projects/carbon-crush/src/components/Sidebar.jsx":"4","/home/myron/Desktop/Projects/carbon-crush/src/game/game.js":"5","/home/myron/Desktop/Projects/carbon-crush/src/game/token.js":"6","/home/myron/Desktop/Projects/carbon-crush/src/components/Gameboard.jsx":"7"},{"size":526,"mtime":1608131681612,"results":"8","hashOfConfig":"9"},{"size":1970,"mtime":1611192807017,"results":"10","hashOfConfig":"9"},{"size":362,"mtime":1608124592348,"results":"11","hashOfConfig":"9"},{"size":374,"mtime":1610952489629,"results":"12","hashOfConfig":"9"},{"size":11883,"mtime":1611181507271,"results":"13","hashOfConfig":"9"},{"size":454,"mtime":1611177356756,"results":"14","hashOfConfig":"9"},{"size":18467,"mtime":1611193378875,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"ibwdj",{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27","usedDeprecatedRules":"18"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/home/myron/Desktop/Projects/carbon-crush/src/index.js",[],["32","33"],"/home/myron/Desktop/Projects/carbon-crush/src/Homepage.js",[],"/home/myron/Desktop/Projects/carbon-crush/src/reportWebVitals.js",[],"/home/myron/Desktop/Projects/carbon-crush/src/components/Sidebar.jsx",[],"/home/myron/Desktop/Projects/carbon-crush/src/game/game.js",["34"],"import { Token } from './token.js';\n\n/**\n * Game is the coordinator for the gameboard and scoreboard. A gameboard is an array of arrays.\n * The gameboard can be a size between 8 to 12. The default size is a 10 x 10 board.\n *\n * Each square contains exactly one greenhouse gas.\n * Each square is identified by its row and column, numbered from 0 to\n * size-1.  Square [0,0] is in the upper-left corner of the carbon-board.\n * Rows are numbered downward, and columns are numbered to the right.\n * The carbon type on each square is random.\n * \n */\n\n/** Constants */\nconst MIN_BOARD_WIDTH = 8;\nconst MIN_BOARD_HEIGHT = 8;\nconst MAX_BOARD_WIDTH = 12;\nconst MAX_BOARD_HEIGHT = 12;\nexport const DEFAULT_WIDTH = 9;\nexport const DEFAULT_HEIGHT = 9;\n\n /** Precondition functions */\nfunction boardConstructorPreconditions(width, height) {\n  if (width < MIN_BOARD_WIDTH) {\n    throw new Error(`Min width of board is ${MIN_BOARD_WIDTH}, got width: ${width}`);\n  }\n  else if (height < MIN_BOARD_HEIGHT) {\n    throw new Error(`Min height of board is ${MIN_BOARD_HEIGHT}, got height: ${height}`);\n  }\n  else if (width > MAX_BOARD_WIDTH) {\n    throw new Error(`Max width of board is ${MAX_BOARD_WIDTH}, got width: ${width}`);\n  }\n  else if (height > MAX_BOARD_HEIGHT) {\n    throw new Error(`Max height of board is ${MAX_BOARD_HEIGHT}, got height: ${height}`);\n  }\n}\n\nexport class Game {\n  constructor(width, height, tokenSet) {\n    try {\n      boardConstructorPreconditions(width, height);\n    }\n    catch (err) {\n      console.error(err);\n    }\n    this.boardWidth = width;\n    this.boardHeight = height;\n    this.boardScore = 0;\n    this.boardSquares = new Array(this.boardHeight);\n    this.tokenSet = tokenSet;\n\n    // initialize an empty board\n    for (let row = 0; row < this.boardHeight; row++) {\n      this.boardSquares[row] = new Array(this.boardWidth);\n      for (let col = 0; col < this.boardWidth; col++) {\n        this.boardSquares[row][col] = null;\n      }\n    }\n    this.refillTokens();\n    // capture tokens if there available options \n    // we want to generate a game state that doesn't have automatic captures\n    while (this.findCapturedTokens().length !== 0) {\n      this.captureTokens(false);\n      this.refillTokens();\n    }\n  }\n\n  /**\n   * Returns the gameboard.\n   * @returns Array<Array<Token>>\n   */\n  getBoardSquares() {\n    return this.boardSquares;\n  }\n\n  setBoardSquare(token, row, col) {\n    if (!this.isValidLocation(row, col)) {\n      throw new Error(`Invalid location, got row: ${row}, col: ${col}`);\n    }\n    this.boardSquares[row][col] = token;\n  }\n\n  /**\n   * Returns the gameboard width.\n   * @returns number\n   */\n  getBoardWidth() {\n    return this.boardWidth;\n  }\n\n  /**\n   * Returns the gameboard height.\n   * @returns number\n   */\n  getBoardHeight() {\n    return this.boardHeight;\n  }\n\n  /**\n   * Returns the gameboard score.\n   * @returns number\n   */\n  getBoardScore() {\n    return this.boardScore;\n  }\n\n  setBoardScore(score) {\n    this.boardScore = 0;\n  }\n\n  /**\n   * Returns true if the row and column identify a valid square on the board.\n   * @param {*number} row - row value (indexed from 0 - starting from top left going right)\n   * @param {*number} col - column value (indexed from 0 - starting from top left going down)\n   * @returns boolean\n   */\n  isValidLocation(row, col) {\n    return row >= 0 && col >= 0 && row < this.boardHeight && col < this.boardWidth;\n  }\n\n  /**\n   * Returns true if the square corresponding to row and column location is empty \n   * @param {*number} row - row value (indexed from 0 - starting from top left going right)\n   * @param {*number} col - column value (indexed from 0 - starting from top left going down)\n   * @returns boolean\n   */\n  isEmptySquare(row, col) {\n    if (!this.isValidLocation(row, col)) {\n      throw new Error(`Invalid location, got row: ${row}, col: ${col}`);\n    }\n    return this.boardSquares[row][col] === null;\n  }\n\n  /**\n   * Returns the token corresponding to row and column if it is a valid square on the board.\n   * @param {*number} row - row value (indexed from 0 - starting from top left going right)\n   * @param {*number} col - column value (indexed from 0 - starting from top left going down)\n   * @returns Token object or null\n   */\n  getToken(row, col) {\n    if (!this.isValidLocation(row, col)) {\n      throw new Error(`Invalid location, got row: ${row}, col: ${col}`);\n    }\n    return this.boardSquares[row][col];\n  }\n\n    /**\n   * Returns the token corresponding to row and column if it is a valid square on the board.\n   * @param {*number} row - row value (indexed from 0 - starting from top left going right)\n   * @param {*number} col - column value (indexed from 0 - starting from top left going down)\n   * @returns Token object or null\n   */\n  captureToken(row, col) {\n    if (!this.isValidLocation(row, col)) {\n      throw new Error(`Invalid location, got row: ${row}, col: ${col}`);\n    }\n    this.boardScore += this.boardSquares[row][col].value;\n    this.boardSquares[row][col] = null;\n  }\n\n\n  isValidMove(x0, y0, x1, y1) {\n    const isValidDistance = Math.abs(x1 - x0) <= 1 && Math.abs(y1 - y0) <= 1;\n    const isValidLocation = this.isValidLocation(y0, x0) && this.isValidLocation(y1, x1);\n    return isValidDistance && isValidLocation;\n  }\n\n  flipTokens(row0, col0, row1, col1) {\n    if (this.isValidMove(row0, col0, row1, col1)) {\n      let token0 = this.getToken(row0, col0);\n      let token1 = this.getToken(row1, col1)\n      this.boardSquares[row0][col0] = token1;\n      this.boardSquares[row1][col1] = token0;\n      if (token1) {\n        token1.row = row0;\n        token1.col = col0;\n      }\n      if (token0) {\n        token0.row = row1;\n        token0.col = col1;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  captureTokens(shouldScore) {\n    const tokens = this.findCapturedTokens();\n    if (tokens.length === 0) {\n      return false;\n    }\n    for (const token of tokens) {\n      // May need to save board state\n      this.boardSquares[token.row][token.col] = null;\n      if (shouldScore) {\n        this.boardScore += token.value;\n      }\n    }\n    return true;\n  }\n\n  refillTokens() {\n    for (let row = 0; row < this.boardHeight; row++) {\n      for (let col = 0; col < this.boardWidth; col++) {\n        if (this.isEmptySquare(row, col)) {\n          this.boardSquares[row][col] = this.spawnToken(row, col);\n        }\n      }\n    }\n  }\n\n  spawnToken(row, col) {\n    const { regularTokens } = this.tokenSet;\n    const tokenName = regularTokens[Math.floor(Math.random() * regularTokens.length)];\n    return new Token(tokenName, row, col, false);\n  }\n\n  generateToken() {\n    const { regularTokens } = this.tokenSet;\n    const tokenName = regularTokens[Math.floor(Math.random() * regularTokens.length)];\n    return new Token(tokenName, null, null, false);\n  }\n\n  findCapturedTokens() {\n    const tokens = new Set();\n    for (let row = 0; row < this.boardHeight; row++) {\n      for (let col = 0; col < this.boardWidth; col++) {\n        let token = this.getToken(row, col);\n        if (this.detectCapture(token)) {\n          tokens.add(token);\n          if (token.isSpecial) {\n            for (let x = 0; x < this.boardWidth; x++) {\n              token = this.getToken(row, x);\n              tokens.add(token);\n            }\n          }\n        }\n      }\n    }\n    return Array.from(tokens);\n  }\n\n  findQuadrupletCapturedTokens() {\n    const tokens = [];\n    for (let row = 0; row < this.boardHeight; row++) {\n      for (let col = 0; col < this.boardWidth; col++) {\n        let token = this.getToken(row, col);\n        const specialTokens = this.detectQuadrupletCapture(token);\n        if (specialTokens.length > 0) {\n          specialTokens.forEach(t => tokens.push(t));\n        }\n      }\n    }\n    return tokens;\n  }\n\n  detectQuadrupletCapture(token) {\n    const { row, col, name } = token;\n    const tokenSet = [];\n    \n    const leftToken = this.isValidLocation(row, col - 1) ? this.getToken(row, col - 1) : null;\n    const rightToken = this.isValidLocation(row, col + 1) ? this.getToken(row, col + 1) : null;\n    const secondRightToken = this.isValidLocation(row, col + 2) ? this.getToken(row, col + 2) : null;\n    const thirdRightToken = this.isValidLocation(row, col + 3) ? this.getToken(row, col + 3) : null;\n    const fourthRightToken = this.isValidLocation(row, col + 4) ? this.getToken(row, col + 4) : null;\n\n    const rightTokenMatch = rightToken !== null && this.isTokenMatch(name, rightToken.name);\n    const secondRightTokenMatch = secondRightToken !== null && this.isTokenMatch(name, secondRightToken.name);\n    const thirdRightTokenMatch = thirdRightToken !== null && this.isTokenMatch(name, thirdRightToken.name);\n    const fourthRightTokenMatch = fourthRightToken !== null && this.isTokenMatch(name, fourthRightToken.name);\n\n    const hasLeft = leftToken !== null && this.isTokenMatch(name, leftToken.name);\n    const hasHorizontalQuadruplet = rightTokenMatch && secondRightTokenMatch && thirdRightTokenMatch && !fourthRightTokenMatch;\n\n    if (!hasLeft && hasHorizontalQuadruplet) {\n      tokenSet.push([token, rightToken, secondRightToken, thirdRightToken]);\n    }\n\n    const topToken = this.isValidLocation(row - 1, col) ? this.getToken(row - 1, col) : null;\n    const bottomToken = this.isValidLocation(row + 1, col) ? this.getToken(row + 1, col) : null;\n    const secondBottomToken = this.isValidLocation(row + 2, col) ? this.getToken(row + 2, col) : null;\n    const thirdBottomToken = this.isValidLocation(row + 3, col) ? this.getToken(row + 3, col) : null;\n    const fourthBottomToken = this.isValidLocation(row + 4, col) ? this.getToken(row + 4, col) : null;\n\n    const bottomTokenMatch = bottomToken !== null && this.isTokenMatch(name, bottomToken.name);\n    const secondBottomTokenMatch = secondBottomToken !== null && this.isTokenMatch(name, secondBottomToken.name);\n    const thirdBottomTokenMatch = thirdBottomToken !== null && this.isTokenMatch(name, thirdBottomToken.name);\n    const fourthBottomTokenMatch = fourthBottomToken !== null && this.isTokenMatch(name, fourthBottomToken.name);\n\n    const hasTop = topToken !== null && this.isTokenMatch(name, topToken.name);\n    const hasVerticalQuadruplet = bottomTokenMatch && secondBottomTokenMatch && thirdBottomTokenMatch && !fourthBottomTokenMatch;\n\n    if (!hasTop && hasVerticalQuadruplet) {\n      tokenSet.push([token, bottomToken, secondBottomToken, thirdBottomToken]);\n    }\n    return tokenSet;\n  }\n\n  detectCapture(token) {\n    const { row, col, name } = token;\n\n    // check left side and second left side\n    if (this.detectTriplet(row, col - 1, row, col - 2, name)) {\n      return true;\n    }\n    // check left side and right side\n    if (this.detectTriplet(row, col - 1, row, col + 1, name)) {\n      return true;\n    }\n    // check right side and second right side\n    if (this.detectTriplet(row, col + 1, row, col + 2, name)) {\n      return true;\n    }\n    // check up side and second up side\n    if (this.detectTriplet(row - 1, col, row - 2, col, name)) {\n      return true;\n    }\n    // check up side and down side\n    if (this.detectTriplet(row - 1, col, row + 1, col, name)) {\n      return true;\n    }\n    // check down side and second down side\n    if (this.detectTriplet(row + 1, col, row + 2, col, name)) {\n      return true;\n    }\n    return false;\n  }\n\n\n  detectTriplet(firstRow, firstCol, secondRow, secondCol, name) {\n    if (this.isValidLocation(firstRow, firstCol) && this.isValidLocation(secondRow, secondCol)) {\n      const firstToken = this.getToken(firstRow, firstCol);\n      const secondToken = this.getToken(secondRow, secondCol);\n      if (this.isTokenMatch(name, firstToken.name) && this.isTokenMatch(name, secondToken.name)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  isTokenMatch(name, secondName) {\n    return name === secondName || `special-${name}` == secondName || name === `special-${secondName}`;\n  }\n}\n","/home/myron/Desktop/Projects/carbon-crush/src/game/token.js",[],"/home/myron/Desktop/Projects/carbon-crush/src/components/Gameboard.jsx",["35","36","37","38"],{"ruleId":"39","replacedBy":"40"},{"ruleId":"41","replacedBy":"42"},{"ruleId":"43","severity":1,"message":"44","line":343,"column":53,"nodeType":"45","messageId":"46","endLine":343,"endColumn":55},{"ruleId":"47","severity":1,"message":"48","line":15,"column":21,"nodeType":"49","messageId":"50","endLine":15,"endColumn":27},{"ruleId":"51","severity":1,"message":"52","line":37,"column":34,"nodeType":"53","messageId":"54","endLine":37,"endColumn":46},{"ruleId":"47","severity":1,"message":"55","line":39,"column":10,"nodeType":"49","messageId":"50","endLine":39,"endColumn":25},{"ruleId":"47","severity":1,"message":"56","line":361,"column":9,"nodeType":"49","messageId":"50","endLine":361,"endColumn":18},"no-native-reassign",["57"],"no-negated-in-lhs",["58"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-unused-vars","'useRef' is defined but never used.","Identifier","unusedVar","no-new-object","The object literal notation {} is preferrable.","NewExpression","preferLiteral","'loadTokenImages' is defined but never used.","'actionCtx' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]