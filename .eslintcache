[{"/home/myron/Desktop/Projects/carbon-crush/src/index.js":"1","/home/myron/Desktop/Projects/carbon-crush/src/Homepage.js":"2","/home/myron/Desktop/Projects/carbon-crush/src/reportWebVitals.js":"3","/home/myron/Desktop/Projects/carbon-crush/src/components/Sidebar.jsx":"4","/home/myron/Desktop/Projects/carbon-crush/src/game/game.js":"5","/home/myron/Desktop/Projects/carbon-crush/src/game/token.js":"6","/home/myron/Desktop/Projects/carbon-crush/src/components/Gameboard.jsx":"7"},{"size":526,"mtime":1608131681612,"results":"8","hashOfConfig":"9"},{"size":972,"mtime":1608466952519,"results":"10","hashOfConfig":"9"},{"size":362,"mtime":1608124592348,"results":"11","hashOfConfig":"9"},{"size":355,"mtime":1608441461935,"results":"12","hashOfConfig":"9"},{"size":7374,"mtime":1608446119897,"results":"13","hashOfConfig":"9"},{"size":441,"mtime":1608162235166,"results":"14","hashOfConfig":"9"},{"size":6355,"mtime":1608506619715,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"ibwdj",{"filePath":"19","messages":"20","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27","usedDeprecatedRules":"18"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/home/myron/Desktop/Projects/carbon-crush/src/index.js",[],["32","33"],"/home/myron/Desktop/Projects/carbon-crush/src/Homepage.js",["34"],"/home/myron/Desktop/Projects/carbon-crush/src/reportWebVitals.js",[],"/home/myron/Desktop/Projects/carbon-crush/src/components/Sidebar.jsx",[],"/home/myron/Desktop/Projects/carbon-crush/src/game/game.js",["35"],"import { DEFAULT_TOKENS, Token } from './token.js';\n\n/**\n * Game is the coordinator for the gameboard and scoreboard. A gameboard is an array of arrays.\n * The gameboard can be a size between 8 to 12. The default size is a 10 x 10 board.\n *\n * Each square contains exactly one greenhouse gas.\n * Each square is identified by its row and column, numbered from 0 to\n * size-1.  Square [0,0] is in the upper-left corner of the carbon-board.\n * Rows are numbered downward, and columns are numbered to the right.\n * The carbon type on each square is random.\n * \n */\n\n/** Constants */\nconst MIN_BOARD_WIDTH = 8;\nconst MIN_BOARD_HEIGHT = 8;\nconst MAX_BOARD_WIDTH = 12;\nconst MAX_BOARD_HEIGHT = 12;\nexport const DEFAULT_WIDTH = 9;\nexport const DEFAULT_HEIGHT = 9;\n\n /** Precondition functions */\nfunction boardConstructorPreconditions(width, height) {\n  if (width < MIN_BOARD_WIDTH) {\n    throw new Error(`Min width of board is ${MIN_BOARD_WIDTH}, got width: ${width}`);\n  }\n  else if (height < MIN_BOARD_HEIGHT) {\n    throw new Error(`Min height of board is ${MIN_BOARD_HEIGHT}, got height: ${height}`);\n  }\n  else if (width > MAX_BOARD_WIDTH) {\n    throw new Error(`Max width of board is ${MAX_BOARD_WIDTH}, got width: ${width}`);\n  }\n  else if (height > MAX_BOARD_HEIGHT) {\n    throw new Error(`Max height of board is ${MAX_BOARD_HEIGHT}, got height: ${height}`);\n  }\n}\n\nexport class Game {\n  constructor(width, height, tokenSet) {\n    try {\n      boardConstructorPreconditions(width, height);\n    }\n    catch (err) {\n      console.error(err);\n    }\n    this.boardWidth = width;\n    this.boardHeight = height;\n    this.boardScore = 0;\n    this.boardSquares = new Array(this.boardHeight);\n    this.tokenSet = tokenSet;\n\n    // initialize an empty board\n    for (let row = 0; row < this.boardHeight; row++) {\n      this.boardSquares[row] = new Array(this.boardWidth);\n      for (let col = 0; col < this.boardWidth; col++) {\n        this.boardSquares[row][col] = null;\n      }\n    }\n    this.refillTokens();\n    // capture tokens if there available options \n    // we want to generate a game state that doesn't have automatic captures\n    let hasCapturedTokens = this.captureTokens(false);\n    while (hasCapturedTokens) {\n      this.refillTokens();\n      hasCapturedTokens = this.captureTokens(false);\n    }\n  }\n\n  /**\n   * Returns the gameboard.\n   * @returns Array<Array<Token>>\n   */\n  getBoardSquares() {\n    return this.boardSquares;\n  }\n\n  /**\n   * Returns the gameboard width.\n   * @returns number\n   */\n  getBoardWidth() {\n    return this.boardWidth;\n  }\n\n  /**\n   * Returns the gameboard height.\n   * @returns number\n   */\n  getBoardHeight() {\n    return this.boardHeight;\n  }\n\n  /**\n   * Returns the gameboard score.\n   * @returns number\n   */\n  getBoardScore() {\n    return this.boardScore;\n  }\n\n\n  /**\n   * Returns true if the row and column identify a valid square on the board.\n   * @param {*number} row - row value (indexed from 0 - starting from top left going right)\n   * @param {*number} col - column value (indexed from 0 - starting from top left going down)\n   * @returns boolean\n   */\n  isValidLocation(row, col) {\n    return row >= 0 && col >= 0 && row < this.boardHeight && col < this.boardWidth;\n  }\n\n  /**\n   * Returns true if the square corresponding to row and column location is empty \n   * @param {*number} row - row value (indexed from 0 - starting from top left going right)\n   * @param {*number} col - column value (indexed from 0 - starting from top left going down)\n   * @returns boolean\n   */\n  isEmptySquare(row, col) {\n    if (!this.isValidLocation(row, col)) {\n      throw new Error(`Invalid location, got row: ${row}, col: ${col}`);\n    }\n    return this.boardSquares[row][col] === null;\n  }\n\n  /**\n   * Returns the token corresponding to row and column if it is a valid square on the board.\n   * @param {*number} row - row value (indexed from 0 - starting from top left going right)\n   * @param {*number} col - column value (indexed from 0 - starting from top left going down)\n   * @returns Token object or null\n   */\n  getToken(row, col) {\n    if (!this.isValidLocation(row, col)) {\n      throw new Error(`Invalid location, got row: ${row}, col: ${col}`);\n    }\n    return this.boardSquares[row][col];\n  }\n\n  isValidMove(x0, y0, x1, y1) {\n    const isValidDistance = Math.abs(x1 - x0) <= 1 && Math.abs(y1 - y0) <= 1;\n    const isValidLocation = this.isValidLocation(y0, x0) && this.isValidLocation(y1, x1);\n    return isValidDistance && isValidLocation;\n  }\n\n  flipTokens(x0, y0, x1, y1) {\n    if (this.isValidMove(x0, y0, x1, y1)) {\n      let token0 = this.getToken(y0, x0);\n      let token1 = this.getToken(y1, x1)\n      this.boardSquares[y0][x0] = token1;\n      this.boardSquares[y1][x1] = token0;\n      if (token1) {\n        token1.x = x0;\n        token1.y = y0;\n      }\n      if (token0) {\n        token0.x = x1;\n        token0.y = y1;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  captureTokens(shouldScore) {\n    const tokens = this.findCapturedTokens();\n    if (tokens.length === 0) {\n      return false;\n    }\n    for (const token of tokens) {\n      // May need to save board state\n      this.boardSquares[token.row][token.col] = null;\n      if (shouldScore) {\n        this.boardScore += token.value;\n      }\n    }\n    return true;\n  }\n\n  refillTokens() {\n    for (let row = 0; row < this.boardHeight; row++) {\n      for (let col = 0; col < this.boardWidth; col++) {\n        if (this.isEmptySquare(row, col)) {\n          this.boardSquares[row][col] = this.spawnToken(row, col);\n        }\n      }\n    }\n  }\n\n  spawnToken(row, col) {\n    const { regularTokens } = this.tokenSet;\n    const tokenName = regularTokens[Math.floor(Math.random() * regularTokens.length)];\n    return new Token(tokenName, 1, row, col);\n  }\n\n  findCapturedTokens() {\n    const tokens = [];\n    for (let row = 0; row < this.boardHeight; row++) {\n      for (let col = 0; col < this.boardWidth; col++) {\n        let token = this.getToken(row, col);\n        if (this.detectCapture(token)) {\n          tokens.push(token);\n        }\n      }\n    }\n    return tokens;\n  }\n\n  detectCapture(token) {\n    const { row, col, name } = token;\n\n    // check left side and second left side\n    if (this.detectTriplet(row, col - 1, row, col - 2, name)) {\n      return true;\n    }\n    // check left side and right side\n    if (this.detectTriplet(row, col - 1, row, col + 1, name)) {\n      return true;\n    }\n    // check right side and second right side\n    if (this.detectTriplet(row, col + 1, row, col + 2, name)) {\n      return true;\n    }\n    // check up side and second up side\n    if (this.detectTriplet(row - 1, col, row - 2, col, name)) {\n      return true;\n    }\n    // check up side and down side\n    if (this.detectTriplet(row - 1, col, row + 1, col, name)) {\n      return true;\n    }\n    // check down side and second down side\n    if (this.detectTriplet(row - 1, col, row - 2, col, name)) {\n      return true;\n    }\n    return false;\n  }\n\n\n  detectTriplet(firstRow, firstCol, secondRow, secondCol, name) {\n    if (this.isValidLocation(firstRow, firstCol) && this.isValidLocation(secondRow, secondCol)) {\n      const firstToken = this.getToken(firstRow, firstCol);\n      const secondToken = this.getToken(secondRow, secondCol);\n      if (firstToken.name === name && secondToken.name === name) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n","/home/myron/Desktop/Projects/carbon-crush/src/game/token.js",[],"/home/myron/Desktop/Projects/carbon-crush/src/components/Gameboard.jsx",["36"],{"ruleId":"37","replacedBy":"38"},{"ruleId":"39","replacedBy":"40"},{"ruleId":"41","severity":1,"message":"42","line":5,"column":26,"nodeType":"43","messageId":"44","endLine":5,"endColumn":31},{"ruleId":"41","severity":1,"message":"45","line":1,"column":10,"nodeType":"43","messageId":"44","endLine":1,"endColumn":24},{"ruleId":"41","severity":1,"message":"46","line":80,"column":9,"nodeType":"43","messageId":"44","endLine":80,"endColumn":18},"no-native-reassign",["47"],"no-negated-in-lhs",["48"],"no-unused-vars","'Token' is defined but never used.","Identifier","unusedVar","'DEFAULT_TOKENS' is defined but never used.","'actionCtx' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]