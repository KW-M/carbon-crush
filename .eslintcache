[{"/home/myron/Desktop/Projects/carbon-crush/src/index.js":"1","/home/myron/Desktop/Projects/carbon-crush/src/Homepage.js":"2","/home/myron/Desktop/Projects/carbon-crush/src/reportWebVitals.js":"3","/home/myron/Desktop/Projects/carbon-crush/src/components/Sidebar.jsx":"4","/home/myron/Desktop/Projects/carbon-crush/src/game/game.js":"5","/home/myron/Desktop/Projects/carbon-crush/src/game/token.js":"6","/home/myron/Desktop/Projects/carbon-crush/src/components/Gameboard.jsx":"7","/home/myron/Desktop/Projects/carbon-crush/src/components/Timer.jsx":"8"},{"size":526,"mtime":1608131681612,"results":"9","hashOfConfig":"10"},{"size":2271,"mtime":1611340602212,"results":"11","hashOfConfig":"10"},{"size":362,"mtime":1608124592348,"results":"12","hashOfConfig":"10"},{"size":513,"mtime":1611340261998,"results":"13","hashOfConfig":"10"},{"size":17565,"mtime":1611341092645,"results":"14","hashOfConfig":"10"},{"size":848,"mtime":1611340782652,"results":"15","hashOfConfig":"10"},{"size":21028,"mtime":1611202331289,"results":"16","hashOfConfig":"10"},{"size":1415,"mtime":1611340588352,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"ibwdj",{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29","usedDeprecatedRules":"20"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"20"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37"},"/home/myron/Desktop/Projects/carbon-crush/src/index.js",[],["38","39"],"/home/myron/Desktop/Projects/carbon-crush/src/Homepage.js",[],"/home/myron/Desktop/Projects/carbon-crush/src/reportWebVitals.js",[],"/home/myron/Desktop/Projects/carbon-crush/src/components/Sidebar.jsx",[],"/home/myron/Desktop/Projects/carbon-crush/src/game/game.js",["40"],"import { Token } from './token.js';\n\n/**\n * Game is the coordinator for the gameboard and scoreboard. A gameboard is an array of arrays.\n * The gameboard can be a size between 8 to 12. The default size is a 10 x 10 board.\n *\n * Each square contains exactly one greenhouse gas.\n * Each square is identified by its row and column, numbered from 0 to\n * size-1.  Square [0,0] is in the upper-left corner of the carbon-board.\n * Rows are numbered downward, and columns are numbered to the right.\n * The carbon type on each square is random.\n * \n */\n\n/** Constants */\nconst MIN_BOARD_WIDTH = 8;\nconst MIN_BOARD_HEIGHT = 8;\nconst MAX_BOARD_WIDTH = 12;\nconst MAX_BOARD_HEIGHT = 12;\nexport const DEFAULT_WIDTH = 9;\nexport const DEFAULT_HEIGHT = 9;\n\n /** Precondition functions */\nfunction boardConstructorPreconditions(width, height) {\n  if (width < MIN_BOARD_WIDTH) {\n    throw new Error(`Min width of board is ${MIN_BOARD_WIDTH}, got width: ${width}`);\n  }\n  else if (height < MIN_BOARD_HEIGHT) {\n    throw new Error(`Min height of board is ${MIN_BOARD_HEIGHT}, got height: ${height}`);\n  }\n  else if (width > MAX_BOARD_WIDTH) {\n    throw new Error(`Max width of board is ${MAX_BOARD_WIDTH}, got width: ${width}`);\n  }\n  else if (height > MAX_BOARD_HEIGHT) {\n    throw new Error(`Max height of board is ${MAX_BOARD_HEIGHT}, got height: ${height}`);\n  }\n}\n\nexport class Game {\n  constructor(width, height, tokenSet) {\n    try {\n      boardConstructorPreconditions(width, height);\n    }\n    catch (err) {\n      console.error(err);\n    }\n    this.boardWidth = width;\n    this.boardHeight = height;\n    this.boardScore = 0;\n    this.boardSquares = new Array(this.boardHeight);\n    this.tokenSet = tokenSet;\n\n    // initialize an empty board\n    for (let row = 0; row < this.boardHeight; row++) {\n      this.boardSquares[row] = new Array(this.boardWidth);\n      for (let col = 0; col < this.boardWidth; col++) {\n        this.boardSquares[row][col] = null;\n      }\n    }\n    this.refillTokens();\n    // capture tokens if there available options \n    // we want to generate a game state that doesn't have automatic captures\n    while (this.findCapturedTokens().length !== 0) {\n      this.captureTokens(false);\n      this.refillTokens();\n    }\n  }\n\n  /**\n   * Returns the gameboard.\n   * @returns Array<Array<Token>>\n   */\n  getBoardSquares() {\n    return this.boardSquares;\n  }\n\n  setBoardSquare(token, row, col) {\n    if (!this.isValidLocation(row, col)) {\n      throw new Error(`Invalid location, got row: ${row}, col: ${col}`);\n    }\n    this.boardSquares[row][col] = token;\n  }\n\n  /**\n   * Returns the gameboard width.\n   * @returns number\n   */\n  getBoardWidth() {\n    return this.boardWidth;\n  }\n\n  /**\n   * Returns the gameboard height.\n   * @returns number\n   */\n  getBoardHeight() {\n    return this.boardHeight;\n  }\n\n  /**\n   * Returns the gameboard score.\n   * @returns number\n   */\n  getBoardScore() {\n    return this.boardScore;\n  }\n\n  setBoardScore(score) {\n    this.boardScore = 0;\n  }\n\n  /**\n   * Returns true if the row and column identify a valid square on the board.\n   * @param {*number} row - row value (indexed from 0 - starting from top left going right)\n   * @param {*number} col - column value (indexed from 0 - starting from top left going down)\n   * @returns boolean\n   */\n  isValidLocation(row, col) {\n    return row >= 0 && col >= 0 && row < this.boardHeight && col < this.boardWidth;\n  }\n\n  /**\n   * Returns true if the square corresponding to row and column location is empty \n   * @param {*number} row - row value (indexed from 0 - starting from top left going right)\n   * @param {*number} col - column value (indexed from 0 - starting from top left going down)\n   * @returns boolean\n   */\n  isEmptySquare(row, col) {\n    if (!this.isValidLocation(row, col)) {\n      throw new Error(`Invalid location, got row: ${row}, col: ${col}`);\n    }\n    return this.boardSquares[row][col] === null;\n  }\n\n  /**\n   * Returns the token corresponding to row and column if it is a valid square on the board.\n   * @param {*number} row - row value (indexed from 0 - starting from top left going right)\n   * @param {*number} col - column value (indexed from 0 - starting from top left going down)\n   * @returns Token object or null\n   */\n  getToken(row, col) {\n    if (!this.isValidLocation(row, col)) {\n      throw new Error(`Invalid location, got row: ${row}, col: ${col}`);\n    }\n    return this.boardSquares[row][col];\n  }\n\n    /**\n   * Returns the token corresponding to row and column if it is a valid square on the board.\n   * @param {*number} row - row value (indexed from 0 - starting from top left going right)\n   * @param {*number} col - column value (indexed from 0 - starting from top left going down)\n   * @returns Token object or null\n   */\n  captureToken(row, col) {\n    if (!this.isValidLocation(row, col)) {\n      throw new Error(`Invalid location, got row: ${row}, col: ${col}`);\n    }\n    this.boardScore += this.boardSquares[row][col].value;\n    this.boardSquares[row][col] = null;\n  }\n\n\n  isValidMove(x0, y0, x1, y1) {\n    const isValidDistance = Math.abs(x1 - x0) <= 1 && Math.abs(y1 - y0) <= 1;\n    const isValidLocation = this.isValidLocation(y0, x0) && this.isValidLocation(y1, x1);\n    return isValidDistance && isValidLocation;\n  }\n\n  flipTokens(row0, col0, row1, col1) {\n    if (this.isValidMove(row0, col0, row1, col1)) {\n      let token0 = this.getToken(row0, col0);\n      let token1 = this.getToken(row1, col1)\n      this.boardSquares[row0][col0] = token1;\n      this.boardSquares[row1][col1] = token0;\n      if (token1) {\n        token1.row = row0;\n        token1.col = col0;\n      }\n      if (token0) {\n        token0.row = row1;\n        token0.col = col1;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  captureTokens(shouldScore) {\n    const tokens = this.findCapturedTokens();\n    if (tokens.length === 0) {\n      return false;\n    }\n    for (const token of tokens) {\n      // May need to save board state\n      this.boardSquares[token.row][token.col] = null;\n      if (shouldScore) {\n        this.boardScore += token.value;\n      }\n    }\n    return true;\n  }\n\n  refillTokens() {\n    for (let row = 0; row < this.boardHeight; row++) {\n      for (let col = 0; col < this.boardWidth; col++) {\n        if (this.isEmptySquare(row, col)) {\n          this.boardSquares[row][col] = this.spawnToken(row, col);\n        }\n      }\n    }\n  }\n\n  spawnToken(row, col) {\n    const { regularTokens } = this.tokenSet;\n    const tokenName = regularTokens[Math.floor(Math.random() * regularTokens.length)];\n    return new Token(tokenName, row, col, false, false);\n  }\n\n  generateToken() {\n    const { regularTokens } = this.tokenSet;\n    const tokenName = regularTokens[Math.floor(Math.random() * regularTokens.length)];\n    return new Token(tokenName, null, null, false, false);\n  }\n\n  findCapturedTokens() {\n    const tokens = new Set();\n    for (let row = 0; row < this.boardHeight; row++) {\n      for (let col = 0; col < this.boardWidth; col++) {\n        let token = this.getToken(row, col);\n        if (this.detectCapture(token)) {\n          tokens.add(token);\n          if (token.isSpecial) {\n            for (let x = 0; x < this.boardWidth; x++) {\n              token = this.getToken(row, x);\n              tokens.add(token);\n            }\n          }\n        }\n      }\n    }\n    return Array.from(tokens);\n  }\n\n  findQuadrupletCapturedTokens() {\n    const tokens = [];\n    for (let row = 0; row < this.boardHeight; row++) {\n      for (let col = 0; col < this.boardWidth; col++) {\n        let token = this.getToken(row, col);\n        const specialTokens = this.detectQuadrupletCapture(token);\n        if (specialTokens.length > 0) {\n          specialTokens.forEach(t => tokens.push(t));\n        }\n      }\n    }\n    return tokens;\n  }\n\n  detectQuadrupletCapture(token) {\n    const { row, col, name } = token;\n    const tokenSet = [];\n    \n    const leftToken = this.isValidLocation(row, col - 1) ? this.getToken(row, col - 1) : null;\n    const rightToken = this.isValidLocation(row, col + 1) ? this.getToken(row, col + 1) : null;\n    const secondRightToken = this.isValidLocation(row, col + 2) ? this.getToken(row, col + 2) : null;\n    const thirdRightToken = this.isValidLocation(row, col + 3) ? this.getToken(row, col + 3) : null;\n    const fourthRightToken = this.isValidLocation(row, col + 4) ? this.getToken(row, col + 4) : null;\n\n    const rightTokenMatch = rightToken !== null && this.isTokenMatch(name, rightToken.name);\n    const secondRightTokenMatch = secondRightToken !== null && this.isTokenMatch(name, secondRightToken.name);\n    const thirdRightTokenMatch = thirdRightToken !== null && this.isTokenMatch(name, thirdRightToken.name);\n    const fourthRightTokenMatch = fourthRightToken !== null && this.isTokenMatch(name, fourthRightToken.name);\n\n    const hasLeft = leftToken !== null && this.isTokenMatch(name, leftToken.name);\n    const hasHorizontalQuadruplet = rightTokenMatch && secondRightTokenMatch && thirdRightTokenMatch && !fourthRightTokenMatch;\n\n    if (!hasLeft && hasHorizontalQuadruplet) {\n      tokenSet.push([token, rightToken, secondRightToken, thirdRightToken]);\n    }\n\n    const topToken = this.isValidLocation(row - 1, col) ? this.getToken(row - 1, col) : null;\n    const bottomToken = this.isValidLocation(row + 1, col) ? this.getToken(row + 1, col) : null;\n    const secondBottomToken = this.isValidLocation(row + 2, col) ? this.getToken(row + 2, col) : null;\n    const thirdBottomToken = this.isValidLocation(row + 3, col) ? this.getToken(row + 3, col) : null;\n    const fourthBottomToken = this.isValidLocation(row + 4, col) ? this.getToken(row + 4, col) : null;\n\n    const bottomTokenMatch = bottomToken !== null && this.isTokenMatch(name, bottomToken.name);\n    const secondBottomTokenMatch = secondBottomToken !== null && this.isTokenMatch(name, secondBottomToken.name);\n    const thirdBottomTokenMatch = thirdBottomToken !== null && this.isTokenMatch(name, thirdBottomToken.name);\n    const fourthBottomTokenMatch = fourthBottomToken !== null && this.isTokenMatch(name, fourthBottomToken.name);\n\n    const hasTop = topToken !== null && this.isTokenMatch(name, topToken.name);\n    const hasVerticalQuadruplet = bottomTokenMatch && secondBottomTokenMatch && thirdBottomTokenMatch && !fourthBottomTokenMatch;\n\n    if (!hasTop && hasVerticalQuadruplet) {\n      tokenSet.push([token, bottomToken, secondBottomToken, thirdBottomToken]);\n    }\n    return tokenSet;\n  }\n\n  getAllTokensOfType(token) {\n    const tokens = new Set();\n    for (let row = 0; row < this.boardHeight; row++) {\n      for (let col = 0; col < this.boardWidth; col++) {\n        const secondToken = this.getToken(row, col);\n        const { name } = secondToken;\n        if (this.isTokenMatch(token.name, name) || token.isBomb) {\n          tokens.add(secondToken);\n          if (secondToken.isSpecial) {\n            for (let x = 0; x < this.boardWidth; x++) {\n              const nextToken = this.getToken(row, x);\n              tokens.add(nextToken);\n            }\n          }\n        }\n      }\n    }\n    return Array.from(tokens);\n  }\n\n  findBombCapturedTokens() {\n    const tokens = [];\n    for (let row = 0; row < this.boardHeight; row++) {\n      for (let col = 0; col < this.boardWidth; col++) {\n        let token = this.getToken(row, col);\n        const bombTokens = this.detectQuintupletCapture(token);\n        if (bombTokens.length > 0) {\n          bombTokens.forEach(t => tokens.push(t));\n        }\n      }\n    }\n    return tokens;\n  }\n\n  detectQuintupletCapture(token) {\n    const { row, col, name } = token;\n    const tokenSet = [];\n    \n    const leftToken = this.isValidLocation(row, col - 1) ? this.getToken(row, col - 1) : null;\n    const rightToken = this.isValidLocation(row, col + 1) ? this.getToken(row, col + 1) : null;\n    const secondRightToken = this.isValidLocation(row, col + 2) ? this.getToken(row, col + 2) : null;\n    const thirdRightToken = this.isValidLocation(row, col + 3) ? this.getToken(row, col + 3) : null;\n    const fourthRightToken = this.isValidLocation(row, col + 4) ? this.getToken(row, col + 4) : null;\n    const fifthRightToken = this.isValidLocation(row, col + 5) ? this.getToken(row, col + 5) : null;\n    const sixthRightToken = this.isValidLocation(row, col + 6) ? this.getToken(row, col + 6) : null;\n    const seventhRightToken = this.isValidLocation(row, col + 7) ? this.getToken(row, col + 7) : null;\n\n    const rightTokenMatch = rightToken !== null && this.isTokenMatch(name, rightToken.name);\n    const secondRightTokenMatch = secondRightToken !== null && this.isTokenMatch(name, secondRightToken.name);\n    const thirdRightTokenMatch = thirdRightToken !== null && this.isTokenMatch(name, thirdRightToken.name);\n    const fourthRightTokenMatch = fourthRightToken !== null && this.isTokenMatch(name, fourthRightToken.name);\n    const fifthRightTokenMatch = fifthRightToken !== null && this.isTokenMatch(name, fifthRightToken.name);\n    const sixthRightTokenMatch = sixthRightToken !== null && this.isTokenMatch(name, sixthRightToken.name);\n    const seventhRightTokenMatch = seventhRightToken !== null && this.isTokenMatch(name, seventhRightToken.name);\n\n    const hasLeft = leftToken !== null && this.isTokenMatch(name, leftToken.name);\n    const hasHorizontalQuintuple = rightTokenMatch && secondRightTokenMatch && thirdRightTokenMatch && fourthRightTokenMatch;\n\n    if (!hasLeft && hasHorizontalQuintuple) {\n      const horizontalTokens = [token, rightToken, secondRightToken, thirdRightToken, fourthRightToken];\n      if (fifthRightTokenMatch) {\n        horizontalTokens.push(fifthRightToken);\n      }\n      if (sixthRightTokenMatch) {\n        horizontalTokens.push(sixthRightToken)\n      }\n      if (seventhRightTokenMatch) {\n        horizontalTokens.push(seventhRightToken);\n      }\n      tokenSet.push(horizontalTokens);\n    }\n\n    const topToken = this.isValidLocation(row - 1, col) ? this.getToken(row - 1, col) : null;\n    const bottomToken = this.isValidLocation(row + 1, col) ? this.getToken(row + 1, col) : null;\n    const secondBottomToken = this.isValidLocation(row + 2, col) ? this.getToken(row + 2, col) : null;\n    const thirdBottomToken = this.isValidLocation(row + 3, col) ? this.getToken(row + 3, col) : null;\n    const fourthBottomToken = this.isValidLocation(row + 4, col) ? this.getToken(row + 4, col) : null;\n    const fifthBottomToken = this.isValidLocation(row + 5, col) ? this.getToken(row + 5, col) : null;\n    const sixthBottomToken = this.isValidLocation(row + 6, col) ? this.getToken(row + 6, col) : null;\n    const seventhBottomToken = this.isValidLocation(row + 7, col) ? this.getToken(row + 7, col) : null;\n\n    const bottomTokenMatch = bottomToken !== null && this.isTokenMatch(name, bottomToken.name);\n    const secondBottomTokenMatch = secondBottomToken !== null && this.isTokenMatch(name, secondBottomToken.name);\n    const thirdBottomTokenMatch = thirdBottomToken !== null && this.isTokenMatch(name, thirdBottomToken.name);\n    const fourthBottomTokenMatch = fourthBottomToken !== null && this.isTokenMatch(name, fourthBottomToken.name);\n    const fifthBottomTokenMatch = fifthBottomToken !== null && this.isTokenMatch(name, fifthBottomToken.name);\n    const sixthBottomTokenMatch = sixthBottomToken !== null && this.isTokenMatch(name, sixthBottomToken.name);\n    const seventhBottomTokenMatch = seventhBottomToken !== null && this.isTokenMatch(name, seventhBottomToken.name);\n\n    const hasTop = topToken !== null && this.isTokenMatch(name, topToken.name);\n    const hasVerticalQuintuple = bottomTokenMatch && secondBottomTokenMatch && thirdBottomTokenMatch && fourthBottomTokenMatch;\n\n    if (!hasTop && hasVerticalQuintuple) {\n      const verticalTokens = [token, bottomToken, secondBottomToken, thirdBottomToken, fourthBottomToken];\n      if (fifthBottomTokenMatch) {\n        verticalTokens.push(fifthBottomToken);\n      }\n      if (sixthBottomTokenMatch) {\n        verticalTokens.push(sixthBottomToken)\n      }\n      if (seventhBottomTokenMatch) {\n        verticalTokens.push(seventhBottomToken);\n      }\n      tokenSet.push(verticalTokens);\n    }\n    return tokenSet;\n  }\n\n  detectCapture(token) {\n    const { row, col, name } = token;\n\n    // check left side and second left side\n    if (this.detectTriplet(row, col - 1, row, col - 2, name)) {\n      return true;\n    }\n    // check left side and right side\n    if (this.detectTriplet(row, col - 1, row, col + 1, name)) {\n      return true;\n    }\n    // check right side and second right side\n    if (this.detectTriplet(row, col + 1, row, col + 2, name)) {\n      return true;\n    }\n    // check up side and second up side\n    if (this.detectTriplet(row - 1, col, row - 2, col, name)) {\n      return true;\n    }\n    // check up side and down side\n    if (this.detectTriplet(row - 1, col, row + 1, col, name)) {\n      return true;\n    }\n    // check down side and second down side\n    if (this.detectTriplet(row + 1, col, row + 2, col, name)) {\n      return true;\n    }\n    return false;\n  }\n\n\n  detectTriplet(firstRow, firstCol, secondRow, secondCol, name) {\n    if (this.isValidLocation(firstRow, firstCol) && this.isValidLocation(secondRow, secondCol)) {\n      const firstToken = this.getToken(firstRow, firstCol);\n      const secondToken = this.getToken(secondRow, secondCol);\n      if (this.isTokenMatch(name, firstToken.name) && this.isTokenMatch(name, secondToken.name)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  isTokenMatch(name, secondName) {\n    return name === secondName || `special-${name}` == secondName || name === `special-${secondName}`;\n  }\n}\n","/home/myron/Desktop/Projects/carbon-crush/src/game/token.js",[],"/home/myron/Desktop/Projects/carbon-crush/src/components/Gameboard.jsx",["41","42"],"import './Gameboard.css';\nimport CARBON_DIOXIDE from '../assets/carbon-dioxide.png';\nimport CFC from '../assets/cfc.png';\nimport PFC from '../assets/pfc.png';\nimport SULFUR_HEXAFLUORIDE from '../assets/sulfur-hexafluoride.png';\nimport NITROUS_OXIDE from '../assets/nitrous-oxide.png';\nimport METHANE from '../assets/methane.png';\nimport SPECIAL_CARBON_DIOXIDE from '../assets/special-carbon-dioxide.png';\nimport SPECIAL_CFC from '../assets/special-cfc.png';\nimport SPECIAL_PFC from '../assets/special-pfc.png';\nimport SPECIAL_SULFUR_HEXAFLUORIDE from '../assets/special-sulfur-hexafluoride.png';\nimport SPECIAL_NITROUS_OXIDE from '../assets/special-nitrous-oxide.png';\nimport SPECIAL_METHANE from '../assets/special-methane.png';\nimport CARBON_BOMB from '../assets/carbon-bomb.png';\nimport { Token } from '../game/token.js';\nimport { useLayoutEffect, useRef } from 'react';\n\nlet windowWidth = window.innerWidth;\nlet windowHeight = window.innerHeight;\nlet canvasWidth = Math.min(windowWidth * 0.72, windowHeight) * 0.90;\nlet mouseUpEventListener = null;\n\nconst TOKEN_TO_IMAGE_PATH_MAP = {\n  'carbon-dioxide': CARBON_DIOXIDE,\n  'nitrous-oxide': NITROUS_OXIDE,\n  'cfc': CFC,\n  'pfc': PFC,\n  'sulfur-hexafluoride': SULFUR_HEXAFLUORIDE,\n  'methane': METHANE,\n  'special-carbon-dioxide': SPECIAL_CARBON_DIOXIDE,\n  'special-nitrous-oxide': SPECIAL_NITROUS_OXIDE,\n  'special-cfc': SPECIAL_CFC,\n  'special-pfc': SPECIAL_PFC,\n  'special-sulfur-hexafluoride': SPECIAL_SULFUR_HEXAFLUORIDE,\n  'special-methane': SPECIAL_METHANE,\n  'carbon-bomb': CARBON_BOMB,\n};\n\nconst LOADED_TOKEN_IMAGE_CACHE = new Object();\n\n\nfunction loadTokenImages() {\n  for (const key in TOKEN_TO_IMAGE_PATH_MAP) {\n    const tokenImage = new Image();\n    tokenImage.src = TOKEN_TO_IMAGE_PATH_MAP[key];\n    LOADED_TOKEN_IMAGE_CACHE[key] = tokenImage;\n  }\n}\nloadTokenImages();\n\nfunction getTokenImage(name) {\n  if (name in LOADED_TOKEN_IMAGE_CACHE) {\n    return LOADED_TOKEN_IMAGE_CACHE[name];\n  }\n  else {\n    const tokenImage = new Image();\n    tokenImage.src = TOKEN_TO_IMAGE_PATH_MAP[name];\n    LOADED_TOKEN_IMAGE_CACHE[name] = tokenImage;\n    return tokenImage;\n  }\n}\n\n\nfunction computeRow(game, gameCanvasHeight, offsetY) {\n  return Math.floor(offsetY * game.getBoardHeight() / gameCanvasHeight);\n}\n\nfunction computeCol(game, gameCanvasWidth, offsetX) {\n  return Math.floor(offsetX * game.getBoardWidth() / gameCanvasWidth);\n}\n\nfunction tokenMoveCallbackFactory(game, tokenImage, initialXOffset, initialYOffset, mouseX, mouseY) {\n  let prevX = mouseX;\n  let prevY = mouseY;\n  const gameCanvas = document.getElementById(\"gameboard-canvas\");\n  const actionCanvas = document.getElementById('action-canvas');\n  const actionCtx = actionCanvas.getContext('2d');\n  let { left, right, top, bottom } = gameCanvas.getBoundingClientRect();\n  const gameCanvasWidth = right - left;\n  const gameCanvasHeight = bottom - top;\n  const tokenWidth = gameCanvasWidth / game.getBoardWidth();\n  const tokenHeight = gameCanvasHeight / game.getBoardHeight();\n  actionCtx.drawImage(tokenImage, prevX - initialXOffset, prevY - initialYOffset, tokenWidth, tokenHeight);\n\n  function tokenMoveCallback(e) {\n    const { offsetX, offsetY } = e;\n    actionCtx.clearRect(prevX - initialXOffset, prevY - initialYOffset, actionCanvas.width, actionCanvas.height);\n    prevX = offsetX;\n    prevY = offsetY;\n    actionCtx.drawImage(tokenImage, offsetX - initialXOffset, offsetY - initialYOffset, tokenWidth, tokenHeight);\n  }\n  return tokenMoveCallback;\n}\n\nfunction dropTokenAnimation(game) {\n  const gameCanvas = document.getElementById(\"gameboard-canvas\");\n  const gameCtx = gameCanvas.getContext('2d');\n  let { left, right, top, bottom } = gameCanvas.getBoundingClientRect();\n  const gameCanvasWidth = right - left;\n  const gameCanvasHeight = bottom - top;\n  const tokenWidth = gameCanvasWidth / game.getBoardWidth();\n  const tokenHeight = gameCanvasHeight / game.getBoardHeight();\n  const actionCanvas = document.getElementById('action-canvas');\n  const actionCtx = actionCanvas.getContext('2d');\n\n  const tokenDropFrame = 10;\n  const tokenDropRate = tokenHeight / tokenDropFrame;\n\n  // Note the index corresponds to which column the destination belongs to\n  const destinationSquares = new Array(game.getBoardWidth());\n  const totalDestinationSquares = new Array(game.getBoardWidth());\n  const numTokensToGenerate = new Array(game.getBoardWidth());\n  const tokenSquares = new Array(game.getBoardWidth());\n  for (let col = 0; col < game.getBoardWidth(); col++) {\n    let drop = 0;\n    destinationSquares[col] = new Array(game.getBoardHeight());\n    totalDestinationSquares[col] = new Array(game.getBoardHeight());\n    tokenSquares[col] = new Array(game.getBoardHeight());\n    for (let row = game.getBoardHeight() - 1; row >= 0; row--) {\n      tokenSquares[col][row] = game.getToken(row, col);\n      if (game.isEmptySquare(row, col)) {\n        drop += 1;\n        destinationSquares[col][row] = 0;\n        totalDestinationSquares[col][row] = 0;\n      }\n      else {\n        destinationSquares[col][row] = drop * tokenDropFrame;\n        totalDestinationSquares[col][row] = drop;\n      }\n    }\n    numTokensToGenerate[col] = drop;\n  }\n  const generatedTokens = new Array(game.getBoardWidth());\n  const generatedTokenDistance = new Array(game.getBoardWidth());\n  for (let col = 0; col < game.getBoardWidth(); col++) {\n    generatedTokens[col] = new Array(numTokensToGenerate[col]);\n    generatedTokenDistance[col] = new Array(numTokensToGenerate[col]);\n    let i = 0;\n    while (i < numTokensToGenerate[col]) {\n      generatedTokens[col][i] = game.spawnToken(i, col);\n      generatedTokenDistance[col][i] = 0;\n      i++;\n    }\n  }\n  function dropTokenAnimationStep() {\n    let completed = true;\n    for (let col = 0; col < game.getBoardWidth(); col++) {\n      const colDestinationSquares = destinationSquares[col];\n      const colTotalDestinationSquares = totalDestinationSquares[col];\n      const colTokenSquares = tokenSquares[col];\n      const currentX = col * tokenWidth;\n      for (let row = game.getBoardHeight() - 1; row >= 0; row--) {\n        if (colDestinationSquares[row] > 0 && colTokenSquares[row] !== null) {\n          const distanceTravelled = colTotalDestinationSquares[row] * tokenDropFrame - colDestinationSquares[row];\n          const currentY = distanceTravelled * tokenDropRate + colTokenSquares[row].row * tokenHeight;\n          gameCtx.clearRect(currentX, currentY, tokenWidth, tokenHeight);\n          colDestinationSquares[row] -= 1;\n          const tokenImage = getTokenImage(colTokenSquares[row].name);\n          gameCtx.drawImage(tokenImage, currentX, currentY + tokenDropRate, tokenWidth, tokenHeight);\n          completed = false;\n        }\n      }\n      const colGeneratedTokens = generatedTokens[col];\n      const colGeneratedTokenDistance = generatedTokenDistance[col];\n      const totalDistanceTravelled = colGeneratedTokenDistance.length * tokenDropFrame;\n      for (let i = 0; i < colGeneratedTokens.length; i++) {\n        if (colGeneratedTokenDistance[i] < totalDistanceTravelled) {\n          const distanceTravelled = colGeneratedTokenDistance[i];\n          const currentY = -(colGeneratedTokens.length - i) * tokenHeight + distanceTravelled * tokenDropRate;\n          gameCtx.clearRect(currentX, currentY, tokenWidth, tokenHeight);\n          colGeneratedTokenDistance[i] += 1;\n          const tokenImage = getTokenImage(colGeneratedTokens[i].name);\n          gameCtx.drawImage(tokenImage, currentX, currentY + tokenDropRate, tokenWidth, tokenHeight);\n          completed = false;\n        }\n      }\n    }\n    if (!completed) {\n      window.requestAnimationFrame(dropTokenAnimationStep)\n    }\n    else {\n      for (let col = 0; col < game.getBoardWidth(); col++) {\n        const colTotalDestinationSquares = totalDestinationSquares[col];\n        for (let row = game.getBoardHeight() - 1; row >= 0; row--) {\n          if (colTotalDestinationSquares[row] > 0) {\n            const token = game.getToken(row, col);\n            token.row = colTotalDestinationSquares[row] + row;\n            game.setBoardSquare(token, colTotalDestinationSquares[row] + row, col);\n          }\n        }\n        const colGeneratedTokens = generatedTokens[col];\n        for (let i = 0; i < colGeneratedTokens.length; i++) {\n          const token = colGeneratedTokens[i];\n          token.row = i;\n          token.col = col;\n          game.setBoardSquare(token, i, col);\n        }\n      }\n      actionCtx.clearRect(0, 0, actionCanvas.width, actionCanvas.height);\n      const capturedTokens = game.findCapturedTokens();\n      if (capturedTokens.length !== 0) {\n        captureTokenAnimation(game);\n      }\n      else {\n        actionCanvas.style.display = 'none';\n      }\n    }\n  }\n  window.requestAnimationFrame(dropTokenAnimationStep);\n}\n\nfunction captureTokenAnimation(game) {\n  const gameCanvas = document.getElementById(\"gameboard-canvas\");\n  const gameCtx = gameCanvas.getContext(\"2d\");\n  const actionCanvas = document.getElementById('action-canvas');\n  const actionCtx = actionCanvas.getContext('2d');\n  let { left, right, top, bottom } = gameCanvas.getBoundingClientRect();\n  const gameCanvasWidth = right - left;\n  const gameCanvasHeight = bottom - top;\n  const tokenWidth = gameCanvasWidth / game.getBoardWidth();\n  const tokenHeight = gameCanvasHeight / game.getBoardHeight();\n  const capturedTokens = game.findCapturedTokens();\n  const quadrupletCapturedTokens = game.findQuadrupletCapturedTokens();\n  const bombCapturedTokens = game.findBombCapturedTokens();\n  console.log(bombCapturedTokens);\n  for (const token of capturedTokens) {\n    const { row, col } = token;\n    game.captureToken(row, col);\n    gameCtx.clearRect(col * tokenWidth, row * tokenHeight, tokenWidth, tokenHeight);\n  }\n  for (let j = 0; j < bombCapturedTokens.length; j++) {\n    const tokenSet = bombCapturedTokens[j];\n    let randToken = tokenSet[Math.floor(Math.random() * tokenSet.length)];\n    let { row, col } = randToken;\n    while (!game.isEmptySquare(row, col)) {\n      randToken = tokenSet[Math.floor(Math.random() * tokenSet.length)];\n      row = randToken.row;\n      col = randToken.col;\n    }\n    const bombToken = new Token('carbon-bomb', row, col, false, true);\n    game.setBoardSquare(bombToken, row, col);\n    const tokenImage = getTokenImage(bombToken.name);\n    gameCtx.drawImage(tokenImage, col * tokenWidth, row * tokenHeight, tokenWidth, tokenHeight);\n  }\n  for (let i = 0; i < quadrupletCapturedTokens.length; i++) {\n    const tokenSet = quadrupletCapturedTokens[i];\n    let randToken = tokenSet[Math.floor(Math.random() * tokenSet.length)];\n    let { row, col } = randToken;\n    while (!game.isEmptySquare(row, col)) {\n      randToken = tokenSet[Math.floor(Math.random() * tokenSet.length)];\n      row = randToken.row;\n      col = randToken.col;\n    }\n    const specialToken = new Token(`special-${randToken.name}`, row, col, true, false);\n    game.setBoardSquare(specialToken, row, col);\n    const tokenImage = getTokenImage(specialToken.name);\n    gameCtx.drawImage(tokenImage, col * tokenWidth, row * tokenHeight, tokenWidth, tokenHeight);\n  }\n  actionCtx.clearRect(0, 0, actionCanvas.width, actionCanvas.height);\n  const sidebarScore = document.getElementById(\"sidebar-score\");\n  if (sidebarScore) {\n    sidebarScore.innerHTML = `Score: ${game.getBoardScore()}`;\n  }\n  dropTokenAnimation(game);\n}\n\nfunction flipTokenAnimation(game, tokenImage0, row0, col0, tokenImage1, row1, col1) {\n  const gameCanvas = document.getElementById(\"gameboard-canvas\");\n  const gameCtx = gameCanvas.getContext(\"2d\");\n  const actionCanvas = document.getElementById('action-canvas');\n  const actionCtx = actionCanvas.getContext('2d');\n  let { left, right, top, bottom } = gameCanvas.getBoundingClientRect();\n  const gameCanvasWidth = right - left;\n  const gameCanvasHeight = bottom - top;\n  const tokenWidth = gameCanvasWidth / game.getBoardWidth();\n  const tokenHeight = gameCanvasHeight / game.getBoardHeight();\n  const token0row = row0 * tokenWidth;\n  const token0col = col0 * tokenHeight;\n  const token1col = col1 * tokenWidth;\n  const token1row = row1 * tokenHeight;\n  \n  const numAnimationFrames = 10;\n  const animationIncrementCol = (token1col - token0col) / numAnimationFrames;\n  const animationIncrementRow = (token1row - token0row) / numAnimationFrames;\n\n  actionCanvas.style.display = 'block';\n  gameCtx.clearRect(token0col, token0row, tokenWidth, tokenHeight);\n  gameCtx.clearRect(token1col, token1row, tokenWidth, tokenHeight);\n  gameCtx.drawImage(tokenImage0, token0col, token0row, tokenWidth, tokenHeight);\n  actionCtx.drawImage(tokenImage1, left + token1col, top + token1row, tokenWidth, tokenHeight);\n  let prev0row = token0row;\n  let prev0col = token0col;\n  let prev1row = top + token1row;\n  let prev1col = left + token1col;\n  \n  let next0row = token0row + animationIncrementRow;\n  let next0col = token0col + animationIncrementCol;\n  let next1row = top + token1row - animationIncrementRow;\n  let next1col = left + token1col - animationIncrementCol;\n  let numFrames = 0;\n  function flipTokenAnimationStep() {\n    if (numFrames >= numAnimationFrames) {\n      gameCtx.drawImage(tokenImage1, prev1col - left, prev1row - top, tokenWidth, tokenHeight);\n      actionCtx.clearRect(0, 0, actionCanvas.width, actionCanvas.height);\n      captureTokenAnimation(game);\n      return;\n    }\n    gameCtx.clearRect(prev0col, prev0row, tokenWidth, tokenHeight);\n    actionCtx.clearRect(prev1col, prev1row, tokenWidth, tokenHeight);\n    gameCtx.drawImage(tokenImage0, next0col, next0row, tokenWidth, tokenHeight);\n    actionCtx.drawImage(tokenImage1, next1col, next1row, tokenWidth, tokenHeight);\n\n    prev0row = next0row;\n    prev0col = next0col;\n    prev1row = next1row;\n    prev1col = next1col;\n    next0row += animationIncrementRow;\n    next0col += animationIncrementCol;\n    next1row -= animationIncrementRow;\n    next1col -= animationIncrementCol;\n    numFrames += 1;\n    window.requestAnimationFrame(flipTokenAnimationStep);\n  }\n  window.requestAnimationFrame(flipTokenAnimationStep);\n}\n\nfunction bombTokenAnimation(game, bombToken, token) {\n  const gameCanvas = document.getElementById(\"gameboard-canvas\");\n  const gameCtx = gameCanvas.getContext(\"2d\");\n  const tokens = game.getAllTokensOfType(token);\n  console.log(tokens);\n  let { left, right, top, bottom } = gameCanvas.getBoundingClientRect();\n  const gameCanvasWidth = right - left;\n  const gameCanvasHeight = bottom - top;\n  const tokenWidth = gameCanvasWidth / game.getBoardWidth();\n  const tokenHeight = gameCanvasHeight / game.getBoardHeight();\n  for (const bombedToken of tokens) {\n    const { row, col } = bombedToken;\n    game.captureToken(row, col);\n    gameCtx.clearRect(col * tokenWidth, row * tokenHeight, tokenWidth, tokenHeight);\n  }\n  game.captureToken(bombToken.row, bombToken.col);\n  gameCtx.clearRect(bombToken.col * tokenWidth, bombToken.row * tokenHeight, tokenWidth, tokenHeight);\n  const sidebarScore = document.getElementById(\"sidebar-score\");\n  if (sidebarScore) {\n    sidebarScore.innerHTML = `Score: ${game.getBoardScore()}`;\n  }\n  dropTokenAnimation(game);\n}\n\nfunction tokenMouseUpCallbackFactory(game, token, tokenImage, tokenMoveCallback) {\n  const gameCanvas = document.getElementById(\"gameboard-canvas\");\n  const gameCtx = gameCanvas.getContext(\"2d\");\n  const actionCanvas = document.getElementById('action-canvas');\n  const actionCtx = actionCanvas.getContext('2d');\n  let { left, right, top, bottom } = gameCanvas.getBoundingClientRect();\n  const gameCanvasWidth = right - left;\n  const gameCanvasHeight = bottom - top;\n  const tokenWidth = gameCanvasWidth / game.getBoardWidth();\n  const tokenHeight = gameCanvasHeight / game.getBoardHeight();\n  function tokenMouseUpCallback(e) {\n    actionCanvas.removeEventListener('mousemove', tokenMoveCallback);\n    actionCtx.clearRect(0, 0, actionCanvas.clientWidth, actionCanvas.clientHeight);\n    gameCtx.drawImage(tokenImage, token.col * tokenWidth, token.row * tokenHeight, tokenWidth, tokenHeight);\n    if (mouseUpEventListener !== null) {\n      actionCanvas.removeEventListener('mouseup', mouseUpEventListener);\n    }\n    const { offsetX, offsetY } = e;\n    if (offsetX >= left && offsetX <= left + gameCanvasWidth \n      && offsetY >= top && offsetY <= top + gameCanvasHeight)\n    {\n      const row1 = computeRow(game, gameCanvasHeight, offsetY - top);\n      const col1 = computeCol(game, gameCanvasHeight, offsetX - left);\n      if ((Math.abs(row1 - token.row) + Math.abs(col1 - token.col) === 1)) {\n        const row0 = token.row;\n        const col0 = token.col;\n        const tokenName0 = token.name;\n        const token1 = game.getToken(row1, col1);\n        if (token.isBomb) {\n          bombTokenAnimation(game, token, token1);\n          actionCtx.clearRect(0, 0, actionCanvas.width, actionCanvas.height);\n          actionCanvas.style.display = 'none';\n          return;\n        }\n        else if (token1.isBomb) {\n          bombTokenAnimation(game, token1, token);\n          actionCtx.clearRect(0, 0, actionCanvas.width, actionCanvas.height);\n          actionCanvas.style.display = 'none';\n          return;\n        }\n        const tokenName1 = token1.name;\n        const tokenImage0 = getTokenImage(tokenName0);\n        const tokenImage1 = getTokenImage(tokenName1);\n        game.flipTokens(token.row, token.col, row1, col1);\n        const capturedTokens = game.findCapturedTokens();\n        if (capturedTokens.length !== 0) {\n          flipTokenAnimation(game, tokenImage0, row0, col0, tokenImage1, row1, col1);\n        }\n        else {\n          game.flipTokens(row1, col1, row0, col0);\n          actionCtx.clearRect(0, 0, actionCanvas.width, actionCanvas.height);\n          actionCanvas.style.display = 'none';\n        }\n      }\n      else {\n        actionCtx.clearRect(0, 0, actionCanvas.width, actionCanvas.height);\n        actionCanvas.style.display = 'none';\n      }\n    }\n  }\n  return tokenMouseUpCallback;\n}\n\nfunction tokenMouseDownCallbackFactory(game) {\n  const gameCanvas = document.getElementById(\"gameboard-canvas\");\n  const gameCtx = gameCanvas.getContext(\"2d\");\n  const actionCanvas = document.getElementById('action-canvas');\n  const actionCtx = actionCanvas.getContext('2d');\n  const { left, right, top, bottom } = gameCanvas.getBoundingClientRect();\n  const gameCanvasWidth = right - left;\n  const gameCanvasHeight = bottom - top;\n  const tokenWidth = gameCanvasWidth / game.getBoardWidth();\n  const tokenHeight = gameCanvasHeight / game.getBoardHeight();\n\n  function tokenMouseDownCallback(e) {\n    const { offsetX, offsetY } = e;\n    const col = computeCol(game, gameCanvasWidth, offsetX);\n    const row = computeRow(game, gameCanvasHeight, offsetY);\n    const initialYOffset = offsetY - row * tokenHeight;\n    const initialXOffset = offsetX - col * tokenWidth;\n\n    gameCtx.clearRect(col * tokenWidth, row * tokenHeight, tokenWidth, tokenHeight);\n    const token = game.getToken(row, col);\n    const mouseX = left  + offsetX;\n    const mouseY = top + offsetY;\n    const tokenImage = getTokenImage(token.name);\n    actionCanvas.style.display = 'block';\n    const tokenMoveCallback = tokenMoveCallbackFactory(game, tokenImage, initialXOffset, initialYOffset, mouseX, mouseY);\n    actionCanvas.addEventListener('mousemove', tokenMoveCallback);\n    const tokenMouseUpCallback = tokenMouseUpCallbackFactory(game, token, tokenImage, tokenMoveCallback);\n    actionCanvas.addEventListener('mouseup', tokenMouseUpCallback);\n    mouseUpEventListener = tokenMouseUpCallback;\n  }\n  return tokenMouseDownCallback;\n}\n\n\nfunction Gameboard(props) {  \n  const { game } = props;\n  const firstUpdate = useRef(true);\n  useLayoutEffect(() => {\n    if (firstUpdate.current) {\n      firstUpdate.current = false;\n      return;\n    }\n    const gameCanvas = document.getElementById(\"gameboard-canvas\");\n    const gameCtx = gameCanvas.getContext(\"2d\");\n    const { left, right, top, bottom } = gameCanvas.getBoundingClientRect();\n    const gameCanvasWidth = right - left;\n    const gameCanvasHeight = bottom - top;\n    const tokenWidth = gameCanvasWidth / game.getBoardWidth();\n    const tokenHeight = gameCanvasHeight / game.getBoardHeight();\n    gameCtx.clearRect(0, 0, gameCanvasWidth, gameCanvasHeight);\n    for (let row = 0; row < game.getBoardHeight(); row++) {\n      for (let col = 0; col < game.getBoardWidth(); col++) {\n        if (game.isEmptySquare(row, col)) {\n          continue;\n        }\n        const token = game.getToken(row, col);\n        let tokenImage = getTokenImage(token.name);\n        gameCtx.drawImage(tokenImage, token.col * tokenWidth, token.row * tokenHeight, tokenWidth, tokenHeight);\n      }\n    }\n    gameCanvas.addEventListener('mousedown', tokenMouseDownCallbackFactory(game));\n  }, [game]);\n\n  return (\n    <>\n      <section className=\"homepage-gameboard\">\n        <canvas id=\"gameboard-canvas\" className=\"gameboard-canvas\" width={canvasWidth} height={canvasWidth} />\n      </section>\n      <canvas id=\"action-canvas\" className=\"action-canvas\" width={windowWidth} height={windowHeight} />\n    </>\n  );\n}\n\nexport default Gameboard;","/home/myron/Desktop/Projects/carbon-crush/src/components/Timer.jsx",["43","44","45","46"],"import React, { useState, useEffect } from 'react';\n\nexport default function Timer(props) {\n  const { seconds, setSeconds } = props;\n  \n  useEffect(() => {\n    let interval = null;\n    if (seconds > 0) {\n      interval = setInterval(() => {\n        setSeconds(seconds => seconds - 1);\n      }, 1000);\n    }\n    else {\n      clearInterval(interval);\n      const gameCanvas = document.getElementById(\"gameboard-canvas\");\n      const gameCtx = gameCanvas.getContext(\"2d\");\n      const actionCanvas = document.getElementById(\"action-canvas\");\n      const actionCtx = actionCanvas.getContext(\"2d\");\n      const gameCanvasClone = gameCanvas.cloneNode(true);\n      const actionCanvasClone = actionCanvas.cloneNode(true);\n      const gameCanvasCloneCtx = gameCanvasClone.getContext('2d');\n      gameCanvasCloneCtx.drawImage(gameCanvas, 0, 0);\n      gameCanvas.parentNode.replaceChild(gameCanvasClone, gameCanvas);\n      actionCanvas.parentNode.replaceChild(actionCanvasClone, actionCanvas);\n      actionCanvas.style.display = 'none';\n    }\n    return () => clearInterval(interval);\n  }, [seconds]);\n  \n  const timerClassNames = `timer ${seconds < 60 ? 'timer-red' : ''}`;\n  const timerText = seconds < 60 \n    ? `${seconds % 60} seconds remaining` \n    : `${Math.floor(seconds / 60)} minutes and ${seconds % 60} seconds remaining`;\n  return (\n    <section className={timerClassNames}>\n      {timerText}\n    </section>\n  )\n}",{"ruleId":"47","replacedBy":"48"},{"ruleId":"49","replacedBy":"50"},{"ruleId":"51","severity":1,"message":"52","line":451,"column":53,"nodeType":"53","messageId":"54","endLine":451,"endColumn":55},{"ruleId":"55","severity":1,"message":"56","line":39,"column":34,"nodeType":"57","messageId":"58","endLine":39,"endColumn":46},{"ruleId":"59","severity":1,"message":"60","line":418,"column":9,"nodeType":"61","messageId":"62","endLine":418,"endColumn":18},{"ruleId":"59","severity":1,"message":"63","line":1,"column":17,"nodeType":"61","messageId":"62","endLine":1,"endColumn":25},{"ruleId":"59","severity":1,"message":"64","line":16,"column":13,"nodeType":"61","messageId":"62","endLine":16,"endColumn":20},{"ruleId":"59","severity":1,"message":"60","line":18,"column":13,"nodeType":"61","messageId":"62","endLine":18,"endColumn":22},{"ruleId":"65","severity":1,"message":"66","line":28,"column":6,"nodeType":"67","endLine":28,"endColumn":15,"suggestions":"68"},"no-native-reassign",["69"],"no-negated-in-lhs",["70"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-new-object","The object literal notation {} is preferrable.","NewExpression","preferLiteral","no-unused-vars","'actionCtx' is assigned a value but never used.","Identifier","unusedVar","'useState' is defined but never used.","'gameCtx' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'setSeconds'. Either include it or remove the dependency array.","ArrayExpression",["71"],"no-global-assign","no-unsafe-negation",{"desc":"72","fix":"73"},"Update the dependencies array to be: [seconds, setSeconds]",{"range":"74","text":"75"},[1079,1088],"[seconds, setSeconds]"]